#include "ETWMonitor.h"
#include "Logging/LogManager.h"
#include "Tools/Tools.h"
#include <tdh.h>
#include <evntrace.h>
#include <evntcons.h>
#include <iostream>
#include <sstream>

#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "tdh.lib")

namespace AnyFSE::Monitors
{

    static Logger log = LogManager::GetLogger("ETWMonitor");
    // Process Provider GUID for real-time process monitoring
    // {22FB2CD6-0E7B-422B-A0C7-2FAD1FD0E716} - Microsoft-Windows-Kernel-Process
    static const GUID ProcessProviderGuid =
        {0x22fb2cd6, 0x0e7b, 0x422b, {0xa0, 0xc7, 0x2f, 0xad, 0x1f, 0xd0, 0xe7, 0x16}};

    // System Trace Control GUID
    // {9e814aad-3204-11d2-9a82-006008a86939}
    static const GUID SystemTraceControlGuid =
        {0x9e814aad, 0x3204, 0x11d2, {0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39}};

    ETWMonitor::ETWMonitor(const std::wstring &processName)
        :
        m_isRunning(false),
        m_stopRequested(false),
        m_threadHandle(NULL),
        m_sessionHandle(NULL),
        m_consumerHandle(NULL),
        m_traceProperties(nullptr)
    {
        ZeroMemory(&m_logFile, sizeof(m_logFile));
        InitializeTargetUnicodeString(processName);
        m_processNameA = Tools::to_string(processName);
        
        // Generate unique session name
        m_sessionName = L"AnyFSE_ETW_Monitor_" + std::to_wstring(GetCurrentThreadId()) + L"_" + std::to_wstring(GetTickCount64());
    }

    ETWMonitor::~ETWMonitor()
    {
        Stop();
    }

    void ETWMonitor::InitializeTargetUnicodeString(const std::wstring& processName) 
    {   
        // Initialize UNICODE_STRING
        m_targetProcessName.Length = static_cast<USHORT>(processName.size() * sizeof(WCHAR));
        m_targetProcessName.MaximumLength = m_targetProcessName.Length + sizeof(WCHAR);
        m_targetProcessName.Buffer = const_cast<WCHAR *>(processName.c_str());
    }

    bool ETWMonitor::CompareProcessNames(const UNICODE_STRING* detectedName) 
    {
    
        return false;
    }

    bool ETWMonitor::EnableKernelProvider(ULONGLONG keywords) {
        // Try with a private session first
        m_sessionName = L"KernelProcessMonitorSession_" + std::to_wstring(GetCurrentProcessId());
        
        //private static readonly int PropertiesSize = sizeof(TraceEventNativeMethods.EVENT_TRACE_PROPERTIES) + 2 * MaxNameSize * sizeof(char) + MaxExtensionSize;
        ULONG bufferSize = sizeof(EVENT_TRACE_PROPERTIES) + sizeof(WCHAR) * (m_sessionName.length() + 1) + 256;
        PEVENT_TRACE_PROPERTIES props = (PEVENT_TRACE_PROPERTIES)malloc(bufferSize);
        ZeroMemory(props, bufferSize);
        props->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        //props->LogFileNameOffset = props->LoggerNameOffset + sizeof(WCHAR) * (m_sessionName.length() + 1);
        props->Wnode.BufferSize = bufferSize;
        props->Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        // ULONG m_BufferQuantumKB = 64;
        // ULONG m_BufferSizeMB = 64;

        // props->BufferSize = (ULONG)m_BufferQuantumKB;
        // props->MinimumBuffers = (ULONG)(m_BufferSizeMB * 1024 / m_BufferQuantumKB);
        props->LogFileMode = EVENT_TRACE_INDEPENDENT_SESSION_MODE | EVENT_TRACE_REAL_TIME_MODE | EVENT_TRACE_SYSTEM_LOGGER_MODE;
        props->LogFileNameOffset = 0;
        //props->MaximumBuffers = props->MinimumBuffers * 5 / 4 + 10;
        props->Wnode.ClientContext = 1;
        props->FlushTimer = 1;
        // props->EnableFlags = keywords;
          
        
        wcscpy_s((WCHAR*)((BYTE*)props + props->LoggerNameOffset), 
            m_sessionName.length() + 1, m_sessionName.c_str());

        ULONG status = StartTrace(&m_sessionHandle, m_sessionName.c_str(), props);
        free(props);
        
        return status == ERROR_SUCCESS;
    }


    HANDLE ETWMonitor::Run(bool &cancelToken)
    {
        if (m_isRunning)
        {
            log.Info("Monitoring already running for process: %s", m_processNameA.c_str());
            return m_threadHandle;
        }

        m_stopRequested = false;
        m_isRunning = true;

        // Enable process events (Process Create = 0x10)
        if (!EnableKernelProvider(0x0001)) {
            log.Error(log.APIError(), "EnableKernelProvider Fail");
            return NULL;
        }


        m_monitoringThread = std::thread(&ETWMonitor::MonitoringThread, this, std::ref(cancelToken));
        m_threadHandle = m_monitoringThread.native_handle();

        log.Info("Started monitoring for process: %s", m_processNameA.c_str());
        return m_threadHandle;
    }

    void ETWMonitor::MonitoringThread(bool &cancelToken)
    {
        EVENT_TRACE_LOGFILE logFile = {0};
        logFile.LoggerName = (LPWSTR)m_sessionName.c_str();
        logFile.ProcessTraceMode = PROCESS_TRACE_MODE_EVENT_RECORD | PROCESS_TRACE_MODE_REAL_TIME;
        logFile.EventRecordCallback = EventRecordCallback;
        logFile.Context = this;

        m_traceHandle = OpenTrace(&logFile);
        if (m_traceHandle == INVALID_PROCESSTRACE_HANDLE) {
            std::wcerr << L"OpenTrace failed: " << GetLastError() << std::endl;
            return;
        }

        while (!cancelToken) {
            DWORD status = ProcessTrace(&m_traceHandle, 1, NULL, NULL);
            if (status != ERROR_SUCCESS && status != ERROR_CANCELLED) {
                break;
            }
            Sleep(100);
        }

        CloseTrace(m_traceHandle);
    }

     // Static callback function
    void WINAPI ETWMonitor::EventRecordCallback(EVENT_RECORD *eventRecord)
    {
        if (eventRecord && eventRecord->UserContext)
        {
            ETWMonitor *monitor = static_cast<ETWMonitor *>(eventRecord->UserContext);
            monitor->ProcessEvent(eventRecord);
        }
    }

    void ETWMonitor::ProcessEvent(EVENT_RECORD *eventRecord)
    {
        // Fast checks first
        if (!IsEqualGUID(eventRecord->EventHeader.ProviderId, ProcessProviderGuid) ||
            eventRecord->EventHeader.EventDescriptor.Opcode != 1) {
            return;
        }

        // Check if we have enough data
        if (eventRecord->UserDataLength < sizeof(ETW_PROCESS_START)) {
            return;
        }

        // Direct structure mapping
        const ETW_PROCESS_START *processStart = reinterpret_cast<const ETW_PROCESS_START *>(eventRecord->UserData);

        if (!processStart->ImageFileName) {
            return;
        }

        const UNICODE_STRING *detectedName = reinterpret_cast<const UNICODE_STRING *>(processStart->ImageFileName);

        // Fast comparison
        if (CompareProcessNames(detectedName))
        {
            log.Info("Target process executed: %s (PID: %lu)", m_processNameA.c_str(), processStart->ProcessId);
            OnProcessExecuted.Notify();
        }
    }

    void ETWMonitor::Stop()
    {
        if (!m_isRunning) {
            log.Info("Stop called but monitoring is not running for process: %s", m_processNameA.c_str());
            return;
        }

        log.Info("Stopping monitoring for process: %s", m_processNameA.c_str());
        m_stopRequested = true;

        // Signal ProcessTrace to stop
        if (m_consumerHandle != NULL) {
            CloseTrace(m_consumerHandle);
            m_consumerHandle = NULL;
        }

        if (m_monitoringThread.joinable()) {
            m_monitoringThread.join();
        }


        m_isRunning = false;
        m_threadHandle = NULL;

        log.Info("Monitoring successfully stopped for process: %s", m_processNameA.c_str());
    }

    HANDLE ETWMonitor::StopAsync()
    {
        if (!m_isRunning) {
            log.Info("StopAsync called but monitoring is not running for process: %s", m_processNameA.c_str());
            return NULL;
        }

        log.Info("Stopping monitoring asynchronously for process: %s", m_processNameA.c_str());
        m_stopRequested = true;

        // Signal ProcessTrace to stop
        if (m_consumerHandle != NULL) {
            CloseTrace(m_consumerHandle);
            m_consumerHandle = NULL;
        }

        return m_threadHandle;
    }

} // namespace AnyFSE::Monitors